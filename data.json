{
  "data": {
    "organization": {
      "repositories": {
        "nodes": [
          {
            "name": "ecmascript_simd",
            "description": "SIMD numeric type for EcmaScript",
            "githubUrl": "https://github.com/tc39/ecmascript_simd",
            "specUrl": null,
            "readme": {
              "text": "# SIMD.js\n===============\n\nSIMD.js has been taken out of active development in TC39 and removed\nfrom Stage 3, and is not being pursued by web browsers for\nimplementation. SIMD operations exposed to the web are under active\ndevelopment within WebAssembly, with operations based on the SIMD.js\noperations. With WebAssembly in advanced development or shipping in\nmultiple browsers, it seems like an adequate vehicle to subsume asm.js\nuse cases, which are judged to be the broader cases. Although some\ndevelopers have expressed interest in using SIMD.js outside of asm.js,\nimplementers have found that implementing and optimizing for this case\nreliably creates a lot of complexity, and have made the decision to\nfocus instead on delivering WebAssembly and SIMD instructions in WASM.\n\nSee https://github.com/WebAssembly/simd for current development.\n\nThis repository retains a historical snapshot of the SIMD.js specification work:\n*  The authoritative API reference documentation is generated from tc39/spec.html. You can view a rendered copy at http://tc39.github.io/ecmascript_simd/ .\n*  A polyfill at src/ecmascript_simd.js, which can't implement value semantics, but includes a correct implementation of all functions\n*  Extensive tests at src/ecmascript_simd_tests.js, which can be run using other files in src/. Benchmarks and example code live in the same directory.\n*  A presentation explaining the motivation and outlining the approach at [tc39/SIMD-128 TC-39.pdf](https://github.com/tc39/ecmascript_simd/blob/master/tc39/SIMD-128%20TC-39.pdf)\n"
            }
          },
          {
            "name": "agendas",
            "description": "TC39 meeting agendas",
            "githubUrl": "https://github.com/tc39/agendas",
            "specUrl": null,
            "readme": {
              "text": "agendas\n=======\n\nTC39 meeting agendas\n<!-- AGENDA_LIST:START (TC39) -->\n<details open>\n<summary>2019</summary>\n\n- [January](./2019/01.md)\n</details>\n\n<details>\n<summary>2018</summary>\n\n- [November](./2018/11.md)\n- [September](./2018/09.md)\n- [July](./2018/07.md)\n- [May](./2018/05.md)\n- [March](./2018/03.md)\n- [January](./2018/01.md)\n</details>\n\n<details>\n<summary>2017</summary>\n\n- [November](./2017/11.md)\n- [September](./2017/09.md)\n- [July](./2017/07.md)\n- [May](./2017/05.md)\n- [March](./2017/03.md)\n- [January](./2017/01.md)\n</details>\n\n<details>\n<summary>2016</summary>\n\n- [November](./2016/11.md)\n- [September](./2016/09.md)\n- [July](./2016/07.md)\n- [May](./2016/05.md)\n- [March](./2016/03.md)\n- [January](./2016/01.md)\n</details>\n\n<details>\n<summary>2015</summary>\n\n- [November](./2015/11.md)\n- [September](./2015/09.md)\n- [July](./2015/07.md)\n- [May](./2015/05.md)\n- [March](./2015/03.md)\n- [January](./2015/01.md)\n</details>\n\n<details>\n<summary>2014</summary>\n\n- [November](./2014/11.md)\n- [September](./2014/09.md)\n- [July](./2014/07.md)\n- [June](./2014/06.md)\n- [April](./2014/04.md)\n- [January](./2014/01.md)\n</details>\n\n<details>\n<summary>2013</summary>\n\n- [November](./2013/11.md)\n- [September](./2013/09.md)\n- [July](./2013/07.md)\n- [May](./2013/05.md)\n</details>\n<!-- AGENDA_LIST:END -->\n"
            }
          },
          {
            "name": "test262",
            "description": "Official ECMAScript Conformance Test Suite",
            "githubUrl": "https://github.com/tc39/test262",
            "specUrl": "",
            "readme": {
              "text": "## Test262: ECMAScript Test Suite ([ECMA TR/104](http://ecma-international.org/publications/techreports/E-TR-104.htm))\n\n\nTest262 is the implementation conformance test suite for the latest drafts (or most recent published edition) of the following Ecma specifications: \n\n- [ECMA-262, ECMAScript Language Specification](https://tc39.github.io/ecma262/)\n- [ECMA-402, ECMAScript Internationalization API Specification](https://tc39.github.io/ecma402/) \n- [ECMA-404, The JSON Data Interchange Format](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf) (pdf)\n\nTest262 itself is described in [ECMA TR/104]((http://ecma-international.org/publications/techreports/E-TR-104.htm)) and is included in [ECMA-414](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-414.pdf) (pdf).\n\n### Goals & State of Test262\n\nThe goal of Test262 is to provide test material that covers every observable behavior specified in the [ECMA-414 Standards Suite](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-414.pdf). Development of Test262 is an on-going process. As of October 2017, Test262 consisted of over 29272 individual test files covering the majority of the pseudo-code algorithms and grammar productions defined in the [ECMA-414 Standards Suite](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-414.pdf). Each of these files contains one or more distinct test cases. This marks the most comprehensive ECMAScript test suite to date. While test coverage is broad, TC39 does not consider coverage to be complete and as with any software project there exists the possibility of omissions and errors. This project welcomes any contributions to Test262 that help make test coverage of existing features more comprehensive.\n\n\n### ECMAScript feature proposals\n\nAs defined in the [TC39 Process](https://tc39.github.io/process-document/), Stage 4 Entrance Criteria requires tests for new feature proposals to advance. Tests may be written by proposal champions, implementers, or any interested community member. \n\nA **proposal champion** is someone that worked on the feature proposal and specification directly.\n\nAn **implementer** is someone that works on implementing the proposal into a JavaScript engine, parser, runtime or embedding. \n \nA **community member** is _you_, and we welcome you to contribute! If you're having trouble getting started, or even just want to ask a question, feel free to open an issue. \n\n### Contributing to Test262\n\nGuidance for contributing to Test262 can be found in [CONTRIBUTING.md](./CONTRIBUTING.md). \n\n**Authors of contributions from non-Ecma member organizations must sign the [Test262 CLA](http://tc39.github.io/test262-cla)**\n\n### Running Test262\n\nGuidance for running Test262 and explanations of how a test file is interpreted by a test runner is in [INTERPRETING](./INTERPRETING.md)\n\n\n### Test262 Runners & Harnesses\n\nVolunteer-maintained projects that may be used to execute Test262 in various ECMAScript hosts:\n\n- https://github.com/bterlson/test262-harness (platform: Node.js)\n- https://github.com/test262-utils/test262-harness-py (platform: Python)\n- https://bakkot.github.io/test262-web-runner/ (platform: web)\n- https://github.com/Izhido/test262_harness_cpp (platform: C++)\n"
            }
          },
          {
            "name": "ecmascript-asyncawait",
            "description": "Async/await for ECMAScript",
            "githubUrl": "https://github.com/tc39/ecmascript-asyncawait",
            "specUrl": "https://tc39.github.io/ecmascript-asyncawait/",
            "readme": {
              "text": "# Async Functions for  ECMAScript\n\nThe introduction of Promises and Generators in ECMAScript presents an opportunity to dramatically improve the language-level model for writing asynchronous code in ECMAScript. The spec text can be found [here](https://tc39.github.io/ecmascript-asyncawait).\n\n\nThis proposal is implemented in a [regenerator](https://github.com/facebook/regenerator) which can compile ES5 code containing `async` and `await` down to vanilla ES5 to run in existing browsers and runtimes.\n\nThis repo contains a complete example using a large number of the features of the proposal.  To run this example:\n\n```Shell\nnpm install\nregenerator -r server.asyncawait.js | node\n```\n\n## Debatable Syntax & Semantics\n\n### Awaiting Non-Promise\nWhen the value passed to `await` is a Promise, the completion of the async function is scheduled on completion of the Promise.  For non-promises, behaviour aligns with Promise conversion rules according to the proposed semantic polyfill.\n\n### Surface syntax\nInstead of `async function`/`await`, the following are options:\n- `function^`/`await`\n- `function!`/`yield`\n- `function!`/`await`\n- `function^`/`yield`\n"
            }
          },
          {
            "name": "ecma262",
            "description": "Status, process, and documents for ECMA262",
            "githubUrl": "https://github.com/tc39/ecma262",
            "specUrl": "https://tc39.github.io/ecma262/",
            "readme": {
              "text": "\nECMAScript\n====\n\n## This repo\n\nThis repository contains the source for the current draft of ECMA-262,\nthe ECMAScriptÂ® Language Specification.\n\nThis source is processed to obtain a human-readable version,\nwhich you can view [here](https://tc39.github.io/ecma262/).\n\n## Current Proposals\n\nProposals follow [the TC39 process](https://tc39.github.io/process-document/) and are tracked in the [proposals repository](https://github.com/tc39/proposals).\n\n* [Finished Proposals](https://github.com/tc39/proposals/blob/master/finished-proposals.md)\n* [Active Proposals](https://github.com/tc39/proposals)\n* [Stage 0 Proposals](https://github.com/tc39/proposals/blob/master/stage-0-proposals.md)\n* [Inactive Proposals](https://github.com/tc39/proposals/blob/master/inactive-proposals.md)\n\n### Contributing New Proposals\n\nPlease see [Contributing to ECMAScript](/CONTRIBUTING.md) for the most up-to-date information on contributing proposals to this standard.\n\n## Developing the Specification\n\nAfter cloning, do `npm install` to set up your environment. You can then do `npm run build` to build the spec or `npm run watch` to set up a continuous build. The results will appear in the `out` directory, which you can use `npm run clean` to delete.\n\n## Community\n\n* [Es-discuss mailing list](https://esdiscuss.org): Mailing list for ECMAScript discussions\n* IRC: #tc39 on Freenode ([instructions](https://freenode.net/kb/answer/chat))\n"
            }
          },
          {
            "name": "test262-cla",
            "description": "CLA for contributions to Test262",
            "githubUrl": "https://github.com/tc39/test262-cla",
            "specUrl": null,
            "readme": null
          },
          {
            "name": "Array.prototype.includes",
            "description": "Spec, tests, reference implementation, and docs for ESnext-track Array.prototype.includes",
            "githubUrl": "https://github.com/tc39/Array.prototype.includes",
            "specUrl": "https://tc39.github.io/Array.prototype.includes/",
            "readme": {
              "text": "# `Array.prototype.includes` Proposal\n\n[Spec](https://tc39.github.io/Array.prototype.includes/)\n\n## Status\n\nThis proposal is officially in stage 4 of [the TC39 process](https://tc39.github.io/process-document/), and is in the process of being integrated into the spec.\n\nThis proposal was formerly for `Array.prototype.contains`, but that name [is not web-compatible](http://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible). Per the November 2014 TC39 meeting, the name of both `String.prototype.contains` and `Array.prototype.contains` was changed to `includes` to dodge that bullet.\n\n## Motivation\n\nWhen using ECMAScript arrays, it is commonly desired to determine if the array includes an element. The prevailing pattern for this is\n\n```js\nif (arr.indexOf(el) !== -1) {\n    ...\n}\n```\n\nwith various other possibilities, e.g. `arr.indexOf(el) >= 0`, or even `~arr.indexOf(el)`.\n\nThese patterns exhibit two problems:\n\n- They fail to \"say what you mean\": instead of asking about whether the array includes an element, you ask what the index of the first occurrence of that element in the array is, and then compare it or bit-twiddle it, to determine the answer to your actual question.\n- They fail for `NaN`, as `indexOf` uses Strict Equality Comparison and thus `[NaN].indexOf(NaN) === -1`.\n\n## Proposed Solution\n\nWe propose the addition of an `Array.prototype.includes` method, such that the above patterns can be rewritten as\n\n```js\nif (arr.includes(el)) {\n    ...\n}\n```\n\nThis has almost the same semantics as the above, except that it uses the SameValueZero comparison algorithm instead of Strict Equality Comparison, thus making `[NaN].includes(NaN)` true.\n\nThus, this proposal solves both problems seen in existing code.\n\nWe additionally add a `fromIndex` parameter, similar to `Array.prototype.indexOf` and `String.prototype.includes`, for consistency.\n\n## FAQs\n\n### Why `includes` instead of `has`?\n\nIf you survey existing APIs, `has` is used for conceptual \"keys,\" whereas `includes` is used for conceptual \"values.\" That is:\n\n- Keys inside a key-value map: `Map.prototype.has(key)`, `WeakMap.prototype.has(key)`, `Reflect.has(target, propertyKey)`\n- Sets, whose elements are conceptually both keys and values: `Set.prototype.has(value)`, `WeakSet.prototype.has(value)`, `Reflect.Loader.prototype.has(name)`\n- Strings, which are conceptually maps from indices to code points: `String.prototype.includes(searchString, position)`\n\nThe best consistency here is with `String`, not with `Map` or `Set`.\n\nThe web has classes like [DOMStringList](https://developer.mozilla.org/en-US/docs/Web/API/DOMStringList) and [DOMTokenList](http://dom.spec.whatwg.org/#interface-domtokenlist) which are array-like, and have methods named `contains` with the same semantics as our `includes`. Unfortunately, meshing with those is not web-compatible, as explained above; we will have to accept this inconsistency.\n\n### But `String.prototype.includes` works on strings, not characters!?\n\nYes, that's true. The best way to think about this is that `String.prototype.indexOf` and `String.prototype.includes` behave like their `Array.prototype` counterparts in the special case of a single character. But the string versions can also be used in the more general case of a larger string.\n\nSo in this way, the relationship between `String.prototype.includes` and `Array.prototype.includes` is the same as the relationship between `String.prototype.indexOf` and `Array.prototype.indexOf`.\n\n### Why SameValueZero?\n\nThere are four equality algorithms in the current ES6 draft:\n\n- Abstract Equality Comparison (`==`)\n- Strict Equality Comparison (`===`): used by `Array.prototype.indexOf`, `Array.prototype.lastIndexOf`, and `case`-matching\n- SameValueZero: used by `%TypedArray%` and `ArrayBuffer` constructors, as well as `Map` and `Set` operations\n- SameValue: used in all other places\n\n(Note however that most places SameValue is used could be replaced by SameValueZero since those places often never compare primitives, or at least never compare numbers.)\n\nUsing Abstract Equality Comparison would be bonkers, of course. Using SameValue is not a good idea for the same reasons it is not used by `Map` and `Set`. (Briefly: `-0`s can sneak into your code fairly easily via arithmetic operations, but you almost always desire `-0` to be treated the same as `+0`, so distinguishing them will just cause spurious failures.) This leaves Strict Equality Comparison and SameValueZero as the two possibilities.\n\nSameValueZero is generally the better choice, as it allows you to detect if an array includes a `NaN`. The argument for Strict Equality Comparison boils down to \"bug compatibility\" with `Array.prototype.indexOf`. But one of the purposes of `Array.prototype.includes` is to steer users away from creating these sort of bugs.\n\nThis introduces a slight refactoring hazard from `Array.prototype.indexOf` to `Array.prototype.includes`: they will indeed behave differently for arrays containing `NaN`s. However, it seems much more likely that code will become _less_ buggy via this refactoring, instead of causing problems. Introducing a new method, and accompanying it with the appropriate messaging around this case, should help.\n\n## Typed Arrays\n\nAs with all non-mutating array methods, we also install this method on `%TypedArray%.prototype`.\n\n## Illustrative Examples\n\n```js\nassert([1, 2, 3].includes(2) === true);\nassert([1, 2, 3].includes(4) === false);\n\nassert([1, 2, NaN].includes(NaN) === true);\n\nassert([1, 2, -0].includes(+0) === true);\nassert([1, 2, +0].includes(-0) === true);\n\nassert([\"a\", \"b\", \"c\"].includes(\"a\") === true);\nassert([\"a\", \"b\", \"c\"].includes(\"a\", 1) === false);\n```\n"
            }
          },
          {
            "name": "proposal-object-rest-spread",
            "description": "Rest/Spread Properties for ECMAScript",
            "githubUrl": "https://github.com/tc39/proposal-object-rest-spread",
            "specUrl": null,
            "readme": {
              "text": "Object Rest/Spread Properties for ECMAScript\n--------------------------------------------\n\nECMAScript 6 introduces [rest elements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) for array destructuring assignment and [spread elements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) for array literals.\n\nThis proposal introduces analogous [rest properties](Rest.md) for object destructuring assignment and [spread properties](Spread.md) for object literals.\n\n### [Specification](https://tc39.github.io/proposal-object-rest-spread/)\n\n[Specification](https://tc39.github.io/proposal-object-rest-spread/)\n\n### [Rest Properties](Rest.md)\n\nRest properties collect the remaining own enumerable property keys that are not already picked off by the destructuring pattern. Those keys and their values are copied onto a new object.\n\n```javascript\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx; // 1\ny; // 2\nz; // { a: 3, b: 4 }\n```\n\n### [Spread Properties](Spread.md)\n\nSpread properties in object initializers copies own enumerable properties from a provided object onto the newly created object.\n\n```javascript\nlet n = { x, y, ...z };\nn; // { x: 1, y: 2, a: 3, b: 4 }\n```\n\n### Transpilers\n\n[Babel](https://babeljs.io/docs/plugins/transform-object-rest-spread/)\n\n[JSTransform](https://github.com/facebook/jstransform)\n\n[TypeScript](https://github.com/Microsoft/TypeScript)\n\n## [Status of this Proposal](https://github.com/tc39/ecma262)\n\nIt is a Stage 4 proposal for ECMAScript.\n\n## [Known Issues](Issues.md)\n\nThis proposal only iterates over __own__ properties. [See why this matters.](Issues.md)\n"
            }
          },
          {
            "name": "proposal-async-iteration",
            "description": "Asynchronous iteration for JavaScript",
            "githubUrl": "https://github.com/tc39/proposal-async-iteration",
            "specUrl": "https://tc39.github.io/proposal-async-iteration/",
            "readme": {
              "text": "# Asynchronous Iterators for JavaScript\n\n## Overview and motivation\n\nThe iterator interface (introduced in ECMAScript 2015) is a sequential data access protocol which enables the development of generic and composable data consumers and transformers. Their primary interface is a `next()` method which returns a `{ value, done }` tuple, where `done` is a boolean indicating whether the end of the iterator has been reached, and `value` is the yielded value in the sequence.\n\nSince both the next value in the sequence and the \"done\" state of the data source must be known at the time that the iterator method returns, iterators are only suitable for representing *synchronous* data sources. While many data sources encountered by the JavaScript programmer are synchronous (such as in-memory lists and other data structures), many others are not. For instance, any data source which requires I/O access will be typically represented using an event-based or streaming *asynchronous* API. Unfortunately, iterators cannot be used to represent such data sources.\n\n(Even an iterator of promises is not sufficient, since that only allows asynchronous determination of the value, but requires synchronous determination of the \"done\" state.)\n\nIn order to provide a generic data access protocol for asynchronous data sources, we introduce the **AsyncIterator** interface, an asynchronous iteration statement (`for`-`await`-`of`), and async generator functions.\n\n## Async iterators and async iterables\n\nAn async iterator is much like an iterator, except that its `next()` method returns a promise for a `{ value, done }` pair. As noted above, we must return a promise for the iterator result pair because both the next value and the \"done\" state of the iterator are potentially unknown at the time the iterator method returns.\n\n```js\nconst { value, done } = syncIterator.next();\n\nasyncIterator.next().then(({ value, done }) => /* ... */);\n```\n\nFurthermore, we introduce a new symbol used for obtaining an async iterator from a given object, `Symbol.asyncIterator`. This allows arbitrary objects to advertise that they are _async iterables_, similar to how `Symbol.iterator` allows you to advertise being a normal, synchronous iterable. An example of a class that might use this is a [readable stream](https://streams.spec.whatwg.org/#rs-class).\n\nImplicit in the concept of the async iterator is the concept of a **request queue**. Since iterator methods may be called many times before the result of a prior request is resolved, each method call must be queued internally until all previous request operations have completed.\n\n## The async iteration statement: `for`-`await`-`of`\n\nWe introduce a variation of the `for-of` iteration statement which iterates over async iterable objects. An example usage would be:\n\n```js\nfor await (const line of readLines(filePath)) {\n  console.log(line);\n}\n```\n\nAsync for-of statements are only allowed within async functions and async generator functions (see below for the latter).\n\nDuring execution, an async iterator is created from the data source using the `[Symbol.asyncIterator]()` method.\n\nEach time we access the next value in the sequence, we implicitly `await` the promise returned from the iterator method.\n\n## Async generator functions\n\nAsync generator functions are similar to generator functions, with the following differences:\n\n- When called, async generator functions return an object, an _async generator_ whose methods (`next`, `throw`, and `return`) return promises for `{ value, done }`, instead of directly returning `{ value, done }`. This automatically makes the returned async generator objects _async iterators_.\n- `await` expressions and `for`-`await`-`of` statements are allowed.\n- The behavior of `yield*` is modified to support delegation to async iterables.\n\nFor example:\n\n```js\nasync function* readLines(path) {\n  let file = await fileOpen(path);\n\n  try {\n    while (!file.EOF) {\n      yield await file.readLine();\n    }\n  } finally {\n    await file.close();\n  }\n}\n```\n\nThis function then returns an async generator object, which can be consumed with `for`-`await`-`of` as shown in the previous example.\n\n## Implementation Status\n\n### Native implementations\n\n- Chakra: [outstanding issue](https://github.com/Microsoft/ChakraCore/issues/2720)\n- JavaScriptCore: [shipping in Safari Tech Preview 40](https://github.com/tc39/proposal-async-iteration/issues/63#issuecomment-330929480)\n- SpiderMonkey: [shipping in Firefox 57](https://github.com/tc39/proposal-async-iteration/issues/63#issuecomment-330978069); [launch bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1352312)\n- V8: [shipping in Chrome 63](https://blog.chromium.org/2017/10/chrome-63-beta-dynamic-module-imports_27.html); [launch bug](https://crbug.com/v8/5855)\n"
            }
          },
          {
            "name": "proposal-trailing-function-commas",
            "description": "",
            "githubUrl": "https://github.com/tc39/proposal-trailing-function-commas",
            "specUrl": null,
            "readme": {
              "text": "# Proposal to allow trailing commas in function parameter lists\n\nIn some codebases/style guides there are scenarios that arise where function calls and definitions are split across multiple lines in the style of:\n\n```js\n 1: function clownPuppiesEverywhere(\n 2:   param1,\n 3:   param2\n 4: ) { /* ... */ }\n 5: \n 6: clownPuppiesEverywhere(\n 7:   'foo',\n 8:   'bar'\n 9: );\n```\n\nIn these cases, when some other code contributor comes along and adds another parameter to one of these parameter lists, they must make two line updates:\n\n```js\n 1: function clownPuppiesEverywhere(\n 2:   param1,\n 3:   param2, // updated to add a comma\n 4:   param3  // updated to add new parameter\n 5: ) { /* ... */ }\n 6: \n 7: clownPuppiesEverywhere(\n 8:   'foo',\n 9:   'bar', // updated to add a comma\n10:   'baz'  // updated to add new parameter\n11: );\n```\n\nIn the process of doing this change on code managed by a version control system (git, subversion, mercurial, etc), the blame/annotation code history information for lines 3 and 9 get updated to point at the person who added the comma (rather than the person who originally added the parameter).\n\nTo help mitigate this problem, some other languages (Python, D, Hack, ...probably others...) have added grammar support to allow a trailing comma in these parameter lists. This allows code contributors to always end a parameter addition with a trailing comma in one of these per-line parameter lists and never have to worry about the code attribution problem again:\n\n```js\n 1: function clownPuppiesEverywhere(\n 2:   param1,\n 3:   param2, // Next parameter that's added only has to add a new line, not modify this line\n 5: ) { /* ... */ }\n 6: \n 7: clownPuppiesEverywhere(\n 8:   'foo',\n 9:   'bar', // Next parameter that's added only has to add a new line, not modify this line\n11: );\n```\n\nNote that this proposal is exclusively about grammar and makes no changes to semantics, therefore the presence of a trailing comma has no effect on things like `<<function>>.length`.\n\nThis repo contains the proposal slides, a version of esprima hacked to allow trailing commas in parameter lists, and a very simple CLI utility to show that it's possible (and easy) to transpile trailing commas to ES5-compatible non-trailing commas in a build step.\n\nFor the CLI, you can either give it a single filename argument to read from disk, or you can pipe source text in to it.\n\n## Spec Text\n\nSee [http://jeffmo.github.io/es-trailing-function-commas/](http://jeffmo.github.io/es-trailing-function-commas/)\n"
            }
          },
          {
            "name": "proposal-bind-operator",
            "description": "This-Binding Syntax for ECMAScript",
            "githubUrl": "https://github.com/tc39/proposal-bind-operator",
            "specUrl": "",
            "readme": {
              "text": "## ECMAScript This-Binding Syntax ##\n\nThis proposal introduces a new operator `::` which performs `this` binding and method extraction.\n\nIt is a more detailed description of the [bind operator strawman](http://wiki.ecmascript.org/doku.php?id=strawman:bind_operator).\n\n### Examples ###\n\nUsing an iterator library implemented as a module of \"virtual methods\":\n\n```js\nimport { map, takeWhile, forEach } from \"iterlib\";\n\ngetPlayers()\n::map(x => x.character())\n::takeWhile(x => x.strength > 100)\n::forEach(x => console.log(x));\n```\n\nUsing a jQuery-like library of virtual methods:\n\n```js\n// Create bindings for just the methods that we need\nlet { find, html } = jake;\n\n// Find all the divs with class=\"myClass\", then get all of the \"p\"s and\n// replace their content.\ndocument.querySelectorAll(\"div.myClass\")::find(\"p\")::html(\"hahaha\");\n```\n\nUsing method extraction to print the eventual value of a promise to the console:\n\n```js\nPromise.resolve(123).then(::console.log);\n```\n\nUsing method extraction to call an object method when a DOM event occurs:\n\n```js\n$(\".some-link\").on(\"click\", ::view.reset);\n```\n\n### Motivation and Overview ###\n\nWith the introduction of arrow functions in ECMAScript 6, the need for explicitly binding closures to the lexical `this` value has been dramatically reduced, resulting in a significant increase in language usability.  However, there are still two use cases where explicit `this` binding or injection is both common and awkward.\n\n**Calling a known function with a supplied `this` argument:**\n\n```js\nlet hasOwnProp = Object.prototype.hasOwnProperty;\nlet obj = { x: 100 };\nhasOwnProp.call(obj, \"x\");\n```\n\n**Extracting a method from an object:**\n\n```js\nPromise.resolve(123).then(console.log.bind(console));\n```\n\nThis proposal introduces a new operator `::` which can be used as syntactic sugar for these use cases.\n\nIn its binary form, the `::` operator creates a bound function such that the left hand side of the operator is bound as the `this` variable to the target function on the right hand side.\n\nIn its unary prefix form, the `::` operator creates a bound function such that the base of the supplied reference is bound as the `this` variable to the target function.\n\nIf the bound function is immediately called, and the target function is strict mode, then the bound function itself is not observable and the bind operator can be optimized to an efficient direct function call.\n\n_NOTE: If the target function is not strict, then it may use `function.callee` or `arguments.callee`, which would result in an observable difference of behavior._\n\nBy providing syntactic sugar for these use cases we will enable a new class of \"virtual method\" library, which will have usability advantages over the standard adapter patterns in use today.\n\n### Prototypes ###\n\n- [Babel](https://github.com/babel/babel) - [REPL](https://babeljs.io/repl/)\n- [esdown](https://github.com/zenparsing/esdown) - [REPL](http://zenparsing.github.io/esdown/repl/)\n\n### Syntax ###\n\n    LeftHandSideExpression[Yield] :\n        NewExpression[?Yield]\n        CallExpression[?Yield]\n        BindExpression[?Yield]\n\n    BindExpression[Yield] :\n        LeftHandSideExpression[?Yield] :: [lookahead â‰  new] MemberExpression[?Yield]\n        :: MemberExpression[?Yield]\n\n    CallExpression[Yield] :\n        MemberExpression[?Yield] Arguments[?Yield]\n        super Arguments[?Yield]\n        CallExpression[?Yield] Arguments[?Yield]\n        CallExpression[?Yield] [ Expression[In, ?Yield] ]\n        CallExpression[?Yield] . IdentifierName\n        CallExpression[?Yield] TemplateLiteral[?Yield]\n        BindExpression[?Yield] Arguments[?Yield]\n\n### Early Errors ###\n\n    BindExpression :\n        :: MemberExpression\n\n- It is a Syntax Error if the derived *MemberExpression* is not *MemberExpression : MemberExpression . Identifier*, *MemberExpression : MemberExpression [ Expression ]*, or *SuperProperty*\n\n- It is a Syntax Error if the derived *NewExpression* is *PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList* and *CoverParenthesizedExpressionAndArrowParameterList* ultimately derives a phrase that, if used in place of *NewExpression*, would produce a Syntax Error according to these rules. This rule is recursively applied.\n\nNOTE:  The last rule means that expressions such as\n\n    ::(((foo)))\n\nproduce early errors because of recursive application of the first rule.\n\n### Abstract Operation: InitializeBoundFunctionProperties ( F, target ) ###\n\nThe abstract operation InitializeBoundFunctionProperties with arguments _F_ and _target_ is used to set the \"length\" and \"name\" properties of a bound function _F_. It performs the following steps:\n\n- Let _targetHasLength_ be HasOwnProperty(_target_, `\"length\"`).\n- If _targetHasLength_ is `true`, then\n    - Let _targetLen_ be ? Get(_target_, `\"length\"`).\n    - If Type(_targetLen_) is not `Number`, then let _L_ be `0`.\n    - Else, let _L_ be ToInteger(_targetLen_).\n- Else let _L_ be `0`.\n- Let _status_ be ? DefinePropertyOrThrow(_F_, `\"length\"`, PropertyDescriptor {[[Value]]: _L_, [[Writable]]: `false`, [[Enumerable]]: `false`, [[Configurable]]: `true`}).\n- Let _targetName_ be ? Get(_target_, `\"name\"`).\n- If Type(_targetName_) is not `String`, then let _targetName_ be the empty string.\n- Let _status_ be ? SetFunctionName(_F_, _targetName_, `\"bound\"`).\n- Return _F_.\n\n### Runtime Semantics ###\n\n    BindExpression :\n        LeftHandSideExpression :: [lookahead â‰  new] MemberExpression\n\n- Let _baseReference_ be the result of evaluating _LeftHandSideExpression_.\n- Let _baseValue_ be GetValue(_baseReference_).\n- Let _targetReference_ be the result of evaluating _MemberExpression_.\n- Let _target_ be GetValue(_targetReference_).\n- If IsCallable(_target_) is `false`, throw a `TypeError` exception.\n- Let _F_ be ? BoundFunctionCreate(_target_, _baseValue_, Â«Â»).\n- Return InitializeBoundFunctionProperties(_F_, _target_).\n\n----\n\n    BindExpression :\n        :: MemberExpression\n\n- Let _targetReference_ be the result of evaluating _MemberExpression_.\n- Assert: IsPropertyReference(_targetReference_) is `true`.\n- Let _thisValue_ be GetThisValue(_targetReference_).\n- Let _target_ be GetValue(_targetReference_).\n- If IsCallable(_target_) is `false`, throw a `TypeError` exception.\n- Let _F_ be ? BoundFunctionCreate(_target_, _thisValue_, Â«Â»).\n- Return ? InitializeBoundFunctionProperties(_F_, _target_).\n\n### Future Extensions:  Bound Constructors ###\n\nThis syntax can be extended by introducing *bound constructors*.  When the binary `::` operator is followed by the `new` keyword, the constructor on the left hand side is wrapped by a callable function.\n\n```js\nclass User {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nlet users = [\"userA\", \"userB\"].map(User::new);\n\nconsole.log(users);\n\n/*\n[ (User) { name: \"userA\" },\n  (User) { name: \"userB\" }]\n*/\n```\n#### Runtime Semantics ####\n\n    BindExpression:\n        LeftHandSideExpression :: new\n\n- Let _targetReference_ be the result of evaluating _LeftHandSideExpression_.\n- Let _target_ be GetValue(_targetReference_).\n- If IsConstructor(_target_) is `false`, throw a `TypeError` exception.\n- Let _F_ be a new built-in function as defined in Bound Constructor Wrapper Functions.\n- Set the [[BoundTargetConstructor]] internal slot of _F_ to _target_.\n- Return ? InitializeBoundFunctionProperties(_F_, _target_).\n\n#### Bound Constructor Wrapper Functions ####\n\nA bound constructor wrapper function is an anonymous built-in function that has a [[BoundTargetConstructor]] internal slot.\n\nWhen a bound constructor wrapper function _F_ is called with zero or more _args_, it performs the following steps:\n\n- Assert: _F_ has a [[BoundTargetConstructor]] internal slot.\n- Let _target_ be the value of _F_'s [[BoundTargetConstructor]] internal slot.\n- Assert: IsConstructor(_target_).\n- Let _args_ be a List consisting of all the arguments passed to this function.\n- Return ? Construct(_target_, _args_).\n"
            }
          },
          {
            "name": "proposal-private-fields",
            "description": "A Private Fields Proposal for ECMAScript",
            "githubUrl": "https://github.com/tc39/proposal-private-fields",
            "specUrl": "https://tc39.github.io/proposal-private-fields/",
            "readme": {
              "text": "## This proposal has been merged into the [class fields](https://github.com/tc39/proposal-class-fields) proposal.\n\nPlease see that repository for current status. The rest of this repository is left up as a historical archive. The old readme is available [here](OLD_README.md), but will not be kept up to date. Similarly, while the FAQ in this repository will continue to exist as is, it will not be updated; its canonical location incluing any updates is in the [class fields repository](https://github.com/tc39/proposal-class-fields/blob/master/PRIVATE_SYNTAX_FAQ.md)."
            }
          },
          {
            "name": "ecma402",
            "description": "Status, process, and documents for ECMA 402",
            "githubUrl": "https://github.com/tc39/ecma402",
            "specUrl": "https://tc39.github.io/ecma402/",
            "readme": {
              "text": "ECMAScript Internationalization API Specification (Ecma-402)\n====\n\n## This repo\n\nThis repository contains the source for the current draft of ECMA-402, the ECMAScriptÂ® Internationalization API Specification.\n\nThis source is processed to obtain a human-readable version, which you can view [here](http://tc39.github.io/ecma402/).\n\n## Current Proposals\n\nProposals follow [the TC39 process](https://tc39.github.io/process-document/) and are tracked in the [proposals repository](https://github.com/tc39/proposals).\n\n* [Finished Proposals](https://github.com/tc39/proposals/blob/master/ecma402/finished-proposals.md)\n* [Active Proposals](https://github.com/tc39/proposals/blob/master/ecma402/README.md)\n* [Stage 0 Proposals](https://github.com/tc39/proposals/blob/master/ecma402/stage-0-proposals.md)\n\n### Contributing New Proposals\n\nPlease see [Contributing to ECMAScript](/CONTRIBUTING.md) for the most up-to-date information on contributing proposals to this standard.\n\n\n## Developing the Specification\n\nAfter cloning, do `npm install` to set up your environment. You can then do `npm run build` to build the spec or `npm run watch` to set up a continuous build. The results will appear in the `out` directory, which you can use `npm run clean` to delete.\n"
            }
          },
          {
            "name": "proposal-cancelable-promises",
            "description": "Former home of the now-withdrawn cancelable promises proposal for JavaScript",
            "githubUrl": "https://github.com/tc39/proposal-cancelable-promises",
            "specUrl": "",
            "readme": {
              "text": "# This proposal has been withdrawn\n\nThis proposal has been withdrawn by its champion and is no longer active in the TC39 process. For reference to previous documentation and specification work, see the Git commit history.\n"
            }
          },
          {
            "name": "proposal-observable",
            "description": "Observables for ECMAScript",
            "githubUrl": "https://github.com/tc39/proposal-observable",
            "specUrl": "https://tc39.github.io/proposal-observable/",
            "readme": {
              "text": "## ECMAScript Observable ##\n\nThis proposal introduces an **Observable** type to the ECMAScript standard library.\nThe **Observable** type can be used to model push-based data sources such as DOM\nevents, timer intervals, and sockets.  In addition, observables are:\n\n- *Compositional*: Observables can be composed with higher-order combinators.\n- *Lazy*: Observables do not start emitting data until an **observer** has subscribed.\n\n### Example: Observing Keyboard Events ###\n\nUsing the **Observable** constructor, we can create a function which returns an\nobservable stream of events for an arbitrary DOM element and event type.\n\n```js\nfunction listen(element, eventName) {\n    return new Observable(observer => {\n        // Create an event handler which sends data to the sink\n        let handler = event => observer.next(event);\n\n        // Attach the event handler\n        element.addEventListener(eventName, handler, true);\n\n        // Return a cleanup function which will cancel the event stream\n        return () => {\n            // Detach the event handler from the element\n            element.removeEventListener(eventName, handler, true);\n        };\n    });\n}\n```\n\nWe can then use standard combinators to filter and map the events in the stream,\njust like we would with an array.\n\n```js\n// Return an observable of special key down commands\nfunction commandKeys(element) {\n    let keyCommands = { \"38\": \"up\", \"40\": \"down\" };\n\n    return listen(element, \"keydown\")\n        .filter(event => event.keyCode in keyCommands)\n        .map(event => keyCommands[event.keyCode])\n}\n```\n\n*Note: The \"filter\" and \"map\" methods are not included in this proposal.  They may\nbe added in a future version of this specification.*\n\nWhen we want to consume the event stream, we subscribe with an **observer**.\n\n```js\nlet subscription = commandKeys(inputElement).subscribe({\n    next(val) { console.log(\"Received key command: \" + val) },\n    error(err) { console.log(\"Received an error: \" + err) },\n    complete() { console.log(\"Stream complete\") },\n});\n```\n\nThe object returned by **subscribe** will allow us to cancel the subscription at any time.\nUpon cancelation, the Observable's cleanup function will be executed.\n\n```js\n// After calling this function, no more events will be sent\nsubscription.unsubscribe();\n```\n\n### Motivation ###\n\nThe Observable type represents one of the fundamental protocols for processing asynchronous\nstreams of data.  It is particularly effective at modeling streams of data which originate\nfrom the environment and are pushed into the application, such as user interface events. By\noffering Observable as a component of the ECMAScript standard library, we allow platforms\nand applications to share a common push-based stream protocol.\n\n### Implementations ###\n\n- [RxJS 5](https://github.com/ReactiveX/RxJS)\n- [zen-observable](https://github.com/zenparsing/zen-observable)\n- [fate-observable](https://github.com/shanewholloway/node-fate-observable)\n\n### Running Tests ###\n\nTo run the unit tests, install the **es-observable-tests** package into your project.\n\n```\nnpm install es-observable-tests\n```\n\nThen call the exported `runTests` function with the constructor you want to test.\n\n```js\nrequire(\"es-observable-tests\").runTests(MyObservable);\n```\n\n### API ###\n\n#### Observable ####\n\nAn Observable represents a sequence of values which may be observed.\n\n```js\ninterface Observable {\n\n    constructor(subscriber : SubscriberFunction);\n\n    // Subscribes to the sequence with an observer\n    subscribe(observer : Observer) : Subscription;\n\n    // Subscribes to the sequence with callbacks\n    subscribe(onNext : Function,\n              onError? : Function,\n              onComplete? : Function) : Subscription;\n\n    // Returns itself\n    [Symbol.observable]() : Observable;\n\n    // Converts items to an Observable\n    static of(...items) : Observable;\n\n    // Converts an observable or iterable to an Observable\n    static from(observable) : Observable;\n\n}\n\ninterface Subscription {\n\n    // Cancels the subscription\n    unsubscribe() : void;\n\n    // A boolean value indicating whether the subscription is closed\n    get closed() : Boolean;\n}\n\nfunction SubscriberFunction(observer: SubscriptionObserver) : (void => void)|Subscription;\n```\n\n#### Observable.of ####\n\n`Observable.of` creates an Observable of the values provided as arguments.  The values\nare delivered synchronously when `subscribe` is called.\n\n```js\nObservable.of(\"red\", \"green\", \"blue\").subscribe({\n    next(color) {\n        console.log(color);\n    }\n});\n\n/*\n > \"red\"\n > \"green\"\n > \"blue\"\n*/\n```\n\n#### Observable.from ####\n\n`Observable.from` converts its argument to an Observable.\n\n- If the argument has a `Symbol.observable` method, then it returns the result of\n  invoking that method.  If the resulting object is not an instance of Observable,\n  then it is wrapped in an Observable which will delegate subscription.\n- Otherwise, the argument is assumed to be an iterable and the iteration values are\n  delivered synchronously when `subscribe` is called.\n\nConverting from an object which supports `Symbol.observable` to an Observable:\n\n```js\nObservable.from({\n    [Symbol.observable]() {\n        return new Observable(observer => {\n            setTimeout(() => {\n                observer.next(\"hello\");\n                observer.next(\"world\");\n                observer.complete();\n            }, 2000);\n        });\n    }\n}).subscribe({\n    next(value) {\n        console.log(value);\n    }\n});\n\n/*\n > \"hello\"\n > \"world\"\n*/\n\nlet observable = new Observable(observer => {});\nObservable.from(observable) === observable; // true\n\n```\n\nConverting from an iterable to an Observable:\n\n```js\nObservable.from([\"mercury\", \"venus\", \"earth\"]).subscribe({\n    next(value) {\n        console.log(value);\n    }\n});\n\n/*\n > \"mercury\"\n > \"venus\"\n > \"earth\"\n*/\n```\n\n#### Observer ####\n\nAn Observer is used to receive data from an Observable, and is supplied as an\nargument to **subscribe**.\n\nAll methods are optional.\n\n```js\ninterface Observer {\n\n    // Receives the subscription object when `subscribe` is called\n    start(subscription : Subscription);\n\n    // Receives the next value in the sequence\n    next(value);\n\n    // Receives the sequence error\n    error(errorValue);\n\n    // Receives a completion notification\n    complete();\n}\n```\n\n#### SubscriptionObserver ####\n\nA SubscriptionObserver is a normalized Observer which wraps the observer object supplied to\n**subscribe**.\n\n```js\ninterface SubscriptionObserver {\n\n    // Sends the next value in the sequence\n    next(value);\n\n    // Sends the sequence error\n    error(errorValue);\n\n    // Sends the completion notification\n    complete();\n\n    // A boolean value indicating whether the subscription is closed\n    get closed() : Boolean;\n}\n```\n"
            }
          },
          {
            "name": "Function-prototype-toString-revision",
            "description": "<g-emoji class=\"g-emoji\" alias=\"fishing_pole_and_fish\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f3a3.png\">ðŸŽ£</g-emoji> ECMA-262 proposal to update Function.prototype.toString",
            "githubUrl": "https://github.com/tc39/Function-prototype-toString-revision",
            "specUrl": "https://tc39.github.io/Function-prototype-toString-revision",
            "readme": {
              "text": "See [the proposal introduction](http://tc39.github.io/Function-prototype-toString-revision) for more info.\n"
            }
          },
          {
            "name": "ecmascript_sharedmem",
            "description": "Shared memory and atomics for ECMAscript",
            "githubUrl": "https://github.com/tc39/ecmascript_sharedmem",
            "specUrl": null,
            "readme": {
              "text": "# ecmascript_sharedmem\n\nThis is a specification for Shared Memory and Atomics for ECMAScript, a proposal submitted to Ecma TC39 and currently at Stage 4 in the ECMAScript approval process.\n\n**IMPORTANT NOTE:**  As of February 2017 this proposal has been merged into the [ECMAScript specification](https://tc39.github.io/ecma262/).  Bug fixing and further evolution take place in that document, and the prose in the present repository will increasingly become irrelevant.  If you find bugs, please check the ECMAScript specification first, and if the bugs are also in that version then please file bugs [in the ecma262 bug tracker](https://github.com/tc39/ecma262/issues), not in this repository.\n\n## Documentation and other materials\n\n* [Formatted specification](http://tc39.github.io/ecmascript_sharedmem/shmem.html)\n* [DOM companion specification](http://tc39.github.io/ecmascript_sharedmem/dom_shmem.html)\n* [asm.js companion specification](http://tc39.github.io/ecmascript_sharedmem/asmjs_shmem.html)\n* [Simple tutorial introduction](TUTORIAL.md)\n* [Demo programs and other examples](DEMOS.md)\n* [Frequently asked questions](FAQ.md)\n* [High-level design issues, cross-cutting concerns, security concerns, etc](DISCUSSION.md)\n* Slide decks for presentations given to Ecma TC39:\n  * [September 2015](https://github.com/tc39/ecmascript_sharedmem/blob/master/tc39/presentation-sept-2015.odp)\n  * [January 2016](https://github.com/tc39/ecmascript_sharedmem/blob/master/tc39/presentation-jan-2016.odp)\n\n## Implementations\n\nFirefox, Chrome and WebKit ship with prototype implementations of the proposal; these are largely compatible.\n\n* The feature is enabled by default in Firefox Nightly; starting with Firefox 46, users of Developer Edition, Aurora, Beta, and Release can visit `about:config` and set the option `javascript.options.shared_memory` to `true`.\n* The feature is off by default in Chrome, but can be enabled by passing the command line options `--js-flags=--harmony-sharedarraybuffer` and `--enable-blink-feature=SharedArrayBuffer`.  (Known to work in Chrome 48.)\n* The feature is enabled by default in WebKit Nightly and Safari Technology Preview as of STP 20.\n\n## Miscellaneous\n\nThe sources for the specs are in the tc39/ subdirectory and the formatted versions are generated with the `format.sh` script.\n\n"
            }
          },
          {
            "name": "ecma262-6-src",
            "description": "This is the source code and tools used to create the ECMAScript 2015 Language Specification",
            "githubUrl": "https://github.com/tc39/ecma262-6-src",
            "specUrl": null,
            "readme": {
              "text": "# ECMA-262 6th Edition Source Files\n\nThis repository contains the source files and tools used to create\nthe  **ECMAScript 2015 Language Specification**.\n\nThe 6th edition has been published and is frozen.  If you want to create  a new edition,\nderived from the 6th edition, start by cloning this repository. Then rename appropriate files\nto match the new edition name.\n\nThe directory `6.0-docs` contains the source files. The file named `\"ECMA-262 6th Edition (final).docx\"`\nis the primary source file. `\"ECMA-262 6th Edition (final).doc\"` is the .doc equivalent of the .docx file.\n\nThe directory `es-spec-html` contains the programs that are used to generate an HTML version\nof the specification from the .docx version."
            }
          },
          {
            "name": "proposal-frozen-realms",
            "description": "Drafting Frozen Realm proposal for ES7",
            "githubUrl": "https://github.com/tc39/proposal-frozen-realms",
            "specUrl": "",
            "readme": {
              "text": "# Draft Proposed Frozen Realm API\n\nThis document specifies complimentary enhancements to the\n[old Realms API proposal](https://gist.github.com/dherman/7568885)\nfocused on making _lightweight realms_ that derive from a shared\n_immutable root realm_. The proposal here is intended to compose well\nwith the remainder of the old `Realm` proposal but is not dependent on\nany of its elements not re-presented here. These proposals each have\nutility without the other, and so can be proposed separately. However,\ntogether they have more power than each separately.\n\nWe motivate the Frozen Realm API presented here with a variety of\nexamples.\n\n### Status\n\nCurrent Stage:\n\n * __Stage 1__\n\n### External links\n\n[Frozen Realms: Draft Standard Support for Safer JavaScript\nPlugins](https://www.youtube.com/watch?v=tuMG7688Ndw)\nis an in-depth talk that covers the important ideas, but is very stale\nregarding specifics.\n\nThe current plan is to settle the [Realms\nproposal](https://github.com/tc39/proposal-realms) first while ensuring that we can\nbuild frozen realms\n   * adequately, in user space\n   * well, with standard platform support if necessary\n\nThe current effort to rebuild frozen realms on top of these Realms is:\n   * [Realms shim](https://github.com/tc39/proposal-realms/tree/master/shim)\n   * [Realms shim\n      playgrouund](https://rawgit.com/tc39/proposal-realms/master/shim/examples/simple.html)\n   * [Frozen Realms\n      shim](https://github.com/tc39/proposal-frozen-realms/tree/master/shim)\n\n\n## Summary\n\nIn ECMAScript, a _realm_ consists of a global object and an associated\nset of _primordial objects_ -- mutable objects like `Array.prototype`\nthat must exist before any code runs. Objects within a realm\nimplicitly share these primordials and can therefore easily disrupt\neach other by _primordial poisoning_ -- modifying these objects to\nbehave badly. This disruption may happen accidentally or\nmaliciously. Today, in the browser, realms can be created via _same\norigin iframes_. On creation, these realms are separate from each\nother. However, to achieve this separation, each realm needs its own\nprimordials, making this separation too expensive to be used at fine\ngrain.\n\nThough initially separate, realms can be brought into intimate contact\nwith each other via host-provided APIs.  For example, in current\nbrowsers, same-origin iframes bring realms into direct contact with\neach other's objects. Once such realms are in contact, the mutability\nof primordials enables an object in one realm to poison the prototypes\nof the other realms.\n\nBorrowing from the\n[old Realms API proposal](https://gist.github.com/dherman/7568885), we\npropose a `Realm` class, each of whose instances is a reification of\nthe \"Realm\" concept. The only elements of the earlier API required here\nare the `global` accessor and the `eval` method, re-explained below.\n\nWe propose a `spawn(endowments)` method on instances of the `Realm`\nclass for making a _lightweight child realm_ consisting of four new\nobjects explained below. Aside from these new objects, the new child\nrealm inherits all its primordials from its parent realm. We propose a\nstatic method, `Realm.immutableRoot()`, for obtaining a realm\nconsisting only of transitively immutable primordials. We call such a\nrealm an _immutable root realm_.\n\n```js\nclass Realm {\n  // From the prior Realm API proposal\n  const global -> object                // access this realm's global object\n  eval(stringable) -> any               // do an indirect eval in this realm\n\n  // We expect the rest of earlier proposal to be re-proposed eventually in\n  // some form, but do not rely here on any of the remainder.\n\n  // New with this proposal\n  static immutableRoot() -> Realm       // transitively immutable realm\n  spawn(endowments) -> Realm            // lightweight child realm\n}\n```\n\nAn immutable root realm consists of all the primordial state defined by\nES2016 (with the exception of the `Date.now` and `Math.random`\nmethods, as explained below). It contains no host provided objects, so\n`window`, `document`, `XMLHttpRequest`, etc. are all absent. Thus,\nan immutable root realm contains none of the objects needed for interacting\nwith the outside world, like the user or the network.\n\nThe `spawn` method makes (1) a new lightweight child realm with (2) a new\n`global` inheriting from its parent's `global`, (3) a new `eval` function\ninheriting from its parent's `eval` function, and (4) a new `Function`\nconstructor inheriting from its parent's `Function` constructor. The new `eval`\nand `Function` will evaluate code in the global scope of the new child realm:\nthe new child realm's `global` becomes their global object. the `spawn` method\nthen copies the own enumerable properties from the `endowments` record onto the\nnew `global` and returns the new realm instance. With these endowments, users\nprovide any host objects that they wish to be available in the spawned realm.\n\nAlthough `immutableRoot()` and `spawn` are orthogonal, they are\nespecially interesting when directly composed:\n\n```js\nconst sharedRoot = Realm.immutableRoot();\nconst realmA = sharedRoot.spawn({});\nconst realmB = sharedRoot.spawn({});\n```\n\nAll the primordials that `realmA` and `realmB` share are immutable, so\nneither can poison the prototypes of the other. Because they share no\nmutable state, they are as fully separate from each other as two full\nrealms created by two same origin iframes.\n\nTwo realms, whether made as above by the `Realm` API or by same origin\niframes, can be put in contact. Once in contact, they can mix their\nobject graphs freely. When same origin iframes do this, they encounter\nan inconvenience and source of bugs we will here call _identity\ndiscontinuity_. For example if code from iframeA makes an array `arr`\nthat it passes to code from iframeB, and iframeB tests `arr instanceof\nArray`, the answer will be `false` since `arr` inherits from the\n`Array.prototype` of iframeA which is a different object than the\n`Array.prototype` of iframeB.\n\nBy contrast, since `realmA` and `realmB` share the `Array.prototype`\nthey inherit from their common immutable `sharedRoot`, an array `arr`\ncreated by one still passes the `arr instanceof Array` as tested by\nthe other. We reuse this immutable `sharedRoot` realm in the examples\nbelow.\n\nA long recognized best practice is \"don't monkey-patch primordials\" --\ndon't mutate any primordial state. Most legacy code obeying this\npractice is already compatible with lightweight realms descending from\nan immutable root realm. Some further qualifications are explained in\nthe rest of this document.\n\n\n## Confinement examples\n\n```js\nfunction confine(src, endowments) {\n  return sharedRoot.spawn(endowments).eval(src);\n}\n```\n\nThis `confine` function is an example of a security abstraction we can\neasily build by composing the primitives above. It uses `spawn` to\nmake a lightweight realm descendant from our immutable `sharedRoot`\nrealm above, copies the own enumerable properties of `endowments` onto\nthe global of that lightweight realm, and then evaluates `src` in the\nscope of that global and returns the result. This `confine` function is\nespecially useful for\n[_object-capability_ programming](https://en.wikipedia.org/wiki/Object-capability_model). These\nprimitives (together with membranes) can also help to support other\nsecurity models such as\n_[decentralized dynamic information flow](https://slang.soe.ucsc.edu/cormac/proxy.pdf)_\nthough more mechanism may additionally be needed. We have not yet\nexplored this in any detail.\n\n(The `confine` function is from SES, which has a\n[formal semantics](http://research.google.com/pubs/pub37199.html)\nsupporting automated verification of some security properties of SES\ncode.  It was developed as part of the Google\n[Caja](https://github.com/google/caja) project; you can read more\nabout SES and Caja on the Caja website.)\n\n\n```js\nconfine('x + y', {x: 3, y: 4})  // -> 7\n\nconfine('Object', {})           // -> Object constructor of an immutable root\n\nconfine('window', {})           // ReferenceError, no 'window' in scope\n```\n\n## Plugin separation example\n\n\n```js\nfunction Counter() {\n  let count = 0;\n  return Object.freeze({\n    incr: Object.freeze(() => ++count),\n    decr: Object.freeze(() => --count)\n  });\n}\nconst counter = new Counter();\n\n// ...obtain billSrc and joanSrc from untrusted clients...\nconst bill = confine(billSrc, {change: counter.incr});\nconst joan = confine(joanSrc, {change: counter.decr});\n```\n\nSay the code above is executed by a program we call Alice. Within this\ncode, Alice obtains source code for plugins Bill and Joan. Alice does\nnot know how well these plugins are written, and so wishes to protect\nherself from their misbehavior, as well as protect each of them from\nthe misbehavior of the other. It does not matter whether Alice is\nworried about accidental or malicious misbehavior.\n\nWith the code above, Alice presents to each of these plugins an API\nsurface of her design, characteristic of the plugin framework she\ndefines. In this trivial example, she provides to each a function they\nwill know as `change` for manipulating the state of a shared\ncounter. By calling his `change` variable, Bill can only increment the\ncounter and see the result. By calling her `change` variable, Joan can\nonly decrement the counter and see the result. By using her `counter`\nvariable Alice can do both.\n\nIf Alice's code above is normal JavaScript code, then she does not achieve this\ngoal. For example, Bill or Joan could use the expression `change.__proto__` to\naccess and poison Alice's prototypes, and to interact with each other in ways\nAlice did not intend to enable. The API surface that Alice exposed to Bill and\nJoan was not _defensive_; it did not protect itself and Alice from Bill and\nJoan's misbehavior.\n\nAlice's code above is properly defensive if it is evaluated in a realm\ndescendant from an immutable root realm. Alice places Bill and Joan in\nsuch a realm to confine them. She places herself in such a realm for\nits _defensibility_, which Alice can use to define defensive\nabstractions that are safe to expose to Bill and Joan. If Alice, Bill,\nand Joan all descend from `sharedRoot`, then their further\ninteractions are defensible and free of identity discontinuities.\n\n\n## A convenience: `def(obj)`\n\nAll those calls to `Object.freeze` above are ugly. The [Caja\n`def(obj)`](https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js#L1180)\nfunction is an example of a convenience that should be provided by a\nlibrary. It applies `Object.freeze` recursively to all objects it finds\nstarting at `obj` by following property and `[[Prototype]]` links. This gives\nall these objects a tamper proof API surface (Note, though, that it *does not*\nmake them immutable except in special cases.) The name `def` means \"_define_ a\n_defensible_ object\".\n\nUsing `def`, we can rewrite our Counter example code as\n\n```js\nfunction Counter() {\n  let count = 0;\n  return def({\n    incr() { return ++count; }\n    decr() { return --count; }\n  });\n}\n```\n\nTo be efficient, `def` needs to somehow be in bed with this\nproposal, so it can know to stop traversing when it hits any of these\ntransitively immutable primordials. We leave it to a later proposal to\nwork out this integration issue.\n\n\n## Compartments example\n\nBy composing\n[revocable membranes](http://soft.vub.ac.be/~tvcutsem/invokedynamic/js-membranes)\nand `confine`, we can make compartments:\n\n```js\nfunction makeCompartment(src, endowments) {\n  const {wrapper,\n         revoke} = makeMembrane(confine);\n  return {wrapper: wrapper(src, endowments),\n          revoke};\n}\n\n// ...obtain billSrc and joanSrc from untrusted clients...\nconst {wrapper: bill,\n       revoke: killBill} = makeCompartment(billSrc, endowments);\nconst {wrapper: joan,\n       revoke: killJoan} = makeCompartment(joanSrc, endowments);\n\n// ... introduce mutually suspicious Bill and Joan to each other...\n// ... use both ...\nkillBill();\n// ... Bill is inaccessible to us and to Joan. GC can collect Bill ...\n```\n\nAfter `killBill` is called, there is nothing the Bill code can do to\ncause further effects.\n\n\n## Date and Math\n\n\nIn order for `sharedRoot` to be shared safely, it must be transitively\nimmutable. Fortunately, of the standard primordials in ES2016, the\nonly mutable primordial state is\n  * Mutable own properties of primordial objects\n  * The mutable internal [[Prototype]] slot of primordial objects, and\n    the ability to add new own properties\n  * The ability to add properties\n  * `Math.random`\n  * `Date.now`\n  * The `Date` constructor called as a constructor with no arguments\n  * The `Date` constructor called as a function, no matter what arguments\n\nTo make a transitively immutable root realm, we, respectively\n  * Make all these properties non-configurable, non-writable. If an\n    accessor property, we specify that its getter must always return\n    the same value and its setter either be absent or throw an error\n    without mutating any state.\n  * Make all primordial objects non-extensible.\n  * Remove `Math.random`\n  * Remove `Date.now`\n  * Have `new Date()` throw a `TypeError`\n  * Have `Date(any...)` throw a `TypeError`\n\nThe **Polyfill example** below shows how a user can effectively add\nthe missing functionality of `Date` and `Math` back in when\nappropriate.\n\n\n## Detailed Proposal\n\nYou can view the spec text draft in [ecmarkup](spec/index.emu) format or rendered as [HTML](https://rawgit.com/tc39/frozen-realms/master/index.html).\n\n  1. Introduce the `Realm` class as an officially recognized part of the\n     ECMAScript standard API.\n\n  1. Add to the `Realm` class a static method, `Realm.immutableRoot()`,\n     which obtains an _immutable root realm_ in which all primordials\n     are already transitively immutable. These primordials include\n     *all* the primordials defined as mandatory in ES2016. (And those\n     in [draft ES2017](https://tc39.github.io/ecma262/) as of March\n     17, 2016, the time of this writing.)  These primordials must\n     include no other objects or properties beyond those specified\n     here. In an immutable root realm the global object itself is also\n     transitively immutable. Specifically, it contains no\n     host-specific objects. This frozen global object is a plain\n     object whose `[[Prototype]]` is `Object.prototype`, i.e., the\n     `%ObjectPrototype%` intrinsic of that immutable root realm.\n\n     * Since two immutable root realms are forever the same in all\n       ways except object identity, we leave it implementation-defined\n       whether `Realm.immutableRoot()` always creates a fresh one, or\n       always returns the same one. On any given implementation, it\n       must either be always fresh or always the same.\n\n  1. In order to attain the necessary deep immutability of an\n     immutable root realm, two of its primordials must be modified\n     from the existing standard: An immutable root realm's `Date`\n     object has its `now()` method removed and its default constructor\n     changed to throw a `TypeError` rather than reveal the current\n     time.  An immutable root realm's `Math` object has its `random()`\n     method removed.\n\n  1. Add to the `Realm` class an instance method, `spawn(endowments)`.\n     1. `spawn` creates a new lightweight child realm with its own\n        fresh global object (denoted below by the symbol\n        `freshGlobal`) whose `[[Prototype]]` is the parent realm's\n        global object. This fresh global is also a plain\n        object. Unlike the global of an immutable root realm, this new\n        `freshGlobal` is _not_ frozen by default.\n\n     1. `spawn` populates this `freshGlobal` with overriding\n        bindings for the evaluators that have global names (currently\n        only `eval` and `Function`). It binds each of these names to\n        fresh objects whose `[[Prototype]]`s are the corresponding\n        objects from the parent realm.\n\n     1. `spawn` copies the own enumerable properties from the\n        `endowments` record onto the `freshGlobal`.\n\n     1. `spawn` returns that new child realm instance.\n\n     The total cost of a lightweight realm is four objects: the realm\n     instance itself, the `freshGlobal`, and the `eval` function and\n     `Function` constructor specific to it.\n\n  1. The evaluators of a spawned realm evaluate code in the global\n     scope of that realm's global, using that\n     global as their global object.\n\n     A lightweight realm's initial `eval` inherits from its parent's\n     `eval`. For each of the overriding constructors (currently only\n     `Function`), its `prototype` property initially has the same\n     value as the constructor they inherit from. Thus, a function\n     `foo` from one descendant realm passes the `foo instanceof\n     Function` test using the `Function` constructor of another\n     descendant of the same parent realm. Among sibling lightweight\n     realms, `instanceof` on primordial types simply works.\n\n\n\n### Polyfill example\n\nIn the **Punchlines** section below, we explain the non-overt channel\nthreats that motivate the removal of `Date.now` and\n`Math.random`. However, usually this threat is not of interest, in\nwhich case we'd rather include the full API of ES2016, since it is\notherwise safe. Indeed, Caja has always provided the full\nfunctionality of `Date` and `Math` because Caja's threat model did not\ndemand that they be denied.\n\nThe following `makeColdRealm(GoodDate, goodRandom)` function, given a\ngood `Date` constructor and `Math.random` function, makes a new\nfrozen-enough lightweight realm, that can be used as if it is an\nimmutable root realm -- as a spawning root for making lightweight\nchild realms. These children are separated-enough from each other,\nif one is not worried about non-overt channels. Unlike the lightweight\nrealms directly descendant from an immutable root realm, children\nspawned from a common cold realm share a fully functional `Date` and\n`Math`.\n\n\n```js\nfunction makeColdRealm(GoodDate, goodRandom) {\n  const goodNow = GoodDate.now;\n  const {Date: SharedDate, Math: SharedMath} = sharedRoot;\n  function FreshDate(...args) {\n    if (new.target) {\n      if (args.length === 0) {\n        args = [+goodNow()];\n      }\n      return Reflect.construct(SharedDate, args, new.target);\n    } else {\n      return String(GoodDate());\n    }\n  }\n  FreshDate.now = () => +goodNow();\n  FreshDate.prototype = SharedDate.prototype;  // so instanceof works\n  FreshDate.name = SharedDate.name;\n  FreshDate.__proto__ = SharedDate;\n\n  const FreshMath = {\n    __proto__: SharedMath,\n    random() { return +goodRandom(); }\n  };\n\n  return def(sharedRoot.spawn({Date: FreshDate, Math: FreshMath}));\n}\n```\n\nIn addition to `Date` and `Math`, we can create abstractions to endow\na fresh global with virtualized emulations of expected host-provided\nglobals like `window`, `document`, or `XMLHttpRequest`. These\nemulations may map into the caller's own or\nnot. [Caja's Domado library](https://github.com/google/caja/blob/master/src/com/google/caja/plugin/domado.js)\nuses exactly this technique to emulate most of the conventional\nbrowser and DOM APIs, by mapping the confined code's virtual DOM into\nthe portions of the caller's \"physical\" DOM that the caller\nspecifies. In this sense, the confined code is like user-mode code in\nan operating system, whose virtual memory accesses are mapped to\nphysical memory by a mapping it does not see or control. Domado remaps\nURI space in a similar manner. By emulating the browser API, much\nexisting browser code runs compatibly in a virtualized browser\nenvironment as configured by the caller using Domado.\n\nBecause `eval`, `Function`, and the above `Date` and `Math` observably\nshadow the corresponding objects from their parent realm, the spawned\nenvironment is not a fully faithful emulation of standard\nECMAScript. However, these breaks in the illusion are a necessary\nprice of avoiding identity discontinuities between lightweight realms\nspawned from a common parent. We have chosen these breaks carefully to\nbe compatible with virtually all code not written specifically to test\nstandards conformance.\n\nThis proposal by itself is not adequate to polyfill intrinsics like\n`%ArrayPrototype%` that can be reached by syntax. Spawning a descendant realm\nusing only the API proposed here, a polyfill can replace what object is looked\nup by the expression `Array.prototype`.  However, the expression `[]` will\nstill evaluate to an array that inherits from the `%ArrayPrototype%` instrinsic\nof the root realm. This is obviously inadequate, but is best addressed by\nmoving the remainder of the [old Realm API\nproposal](https://gist.github.com/dherman/7568885) towards standardization in a\nseparate proposal. Among other things, the full Realm API will provide the\nnecessary methods for manipulating the binding of intrinsics.\n\n\n### Mobile code example\n\nMap-Reduce frameworks vividly demonstrate the power of sending the\ncode to the data, rather than the data to the code. Flexible\ndistributed computing systems must be able to express both.\n\nNow that `Function.prototype.toString` will give a\n[reliably evaluable string](http://tc39.github.io/Function-prototype-toString-revision/)\nthat can be sent, an immutable root realm provides a safe way for the\nreceiver to evaluate it, in order to reconstitute that function's call\nbehavior in a safe manner. Say we have a `RemotePromise` constructor\nthat makes a\n[remote promise for an object that is elsewhere](https://github.com/kriskowal/q-connection),\npotentially on another machine. Below, assume that the `RemotePromise`\nconstructor initializes this remote promise's\n[private instance variable](https://zenparsing.github.io/es-private-fields/)\n`#farEval` to be another remote promise, for the `eval` method of an\nimmutable root realm at the location (vat, worker, agent, event loop,\nplace, ...) where this promise's fulfillment will be. If this promise\nrejects, then its `#farEval` promise likewise rejects.\n\n```js\nclass QPromise extends Promise {\n  // ... API from https://github.com/kriskowal/q/wiki/API-Reference\n  // All we actually use below is fcall\n}\n\n// See https://github.com/kriskowal/q-connection\nclass RemotePromise extends QPromise {\n  ...\n  // callback must be a closed function, i.e., one whose only free\n  // variables are the globals defined by ES2016 and therefore present\n  // on the proto-global.\n  there(callback, errback = void 0) {\n    const callbackSrc = Function.prototype.toString.call(callback);\n    const farCallback = #farEval.fcall(callbackSrc);\n    return farCallback.fcall(this).catch(errback);\n  }\n}\n```\n\nWe explain `there` by analogy. The familiar expression\n`Promise.resolve(p).then(callback)` postpones the `callback` function\nto some future time after the promise `p` has been fulfilled. In like\nmanner, the expression `RemotePromise.resolve(r).there(callback)`\npostpones and migrates the closed `callback` function to some future\ntime and space, where the object that will be designated by the\nfulfilled remote promise `r` is located. Both `then` and `there`\nreturn a promise for what `callback` or `errback` will return.\n\nThis supports a federated form of the\n[Asynchronous Partitioned Global Address Space](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.464.557)\nconcurrency model used by the X10 supercomputer language, integrated\nsmoothly with our promise framework for handling asynchrony.\n\n\n## How Deterministic?\n\n_We do not include any form of replay within the goals of this\nproposal, so this \"How Deterministic\" section is only important\nbecause of the punchlines at the end of this section._\n\nGiven a deterministic spec, one could be sure that two computations,\nrun on two conforming implementations, starting from the same state\nand fed the same inputs, will compute the same new states and\noutputs. The ES5 and ES2015 specs come tantalizingly close to being\ndeterministic. ECMAScript has avoided some common but unnecessary\nsources of non-determinism like Java's `System.identityHashCode` or\nthe enumeration order of identity hash tables. But the ECMAScript\nspecs fail for three reasons:\n\n  * Genuine non-determinism, such as by `Math.random()`.\n  * Unspecified but unavoidable failure, such as out-of-memory.\n  * Explicit underspecification, i.e. leaving some observable behavior\n    up to the implementation.\n\nThe explicitly non-deterministic abilities to sense the current time\n(via `new Date()` and `Date.now()`) or generate random numbers (via\n`Math.random()`) are disabled in an immutable root realm, and\ntherefore by default in each realm spawned from it. New sources of\nnon-determinism, like `makeWeakRef` and `getStack` will not be added\nto immutable root realms or will be similarly disabled.\n\nThe ECMAScript specs to date have never admitted the possibility of\nfailures such as out-of-memory. In theory this means that a conforming\nECMAScript implementation requires an infinite memory\nmachine. Unfortunately, such machines are currently difficult to obtain. Since\nECMAScript is an implicitly-allocating language, the out-of-memory\ncondition could cause computation to fail at any time. If these\nfailures are reported by\n[unpredictably throwing a catchable exception](https://docs.oracle.com/javase/8/docs/api/java/lang/VirtualMachineError.html),\nthen defensive programming becomes impossible. This would be contrary\nto the goals\n[of much ECMAScript code](https://github.com/tc39/ecmascript_sharedmem/issues/55). Thus,\nany ECMAScript computation that wishes to defend its invariants, and\nany synchronous computation it is entangled with must, on encountering an\nunpredictable error,\n[preemptively abort without running further user code](https://github.com/tc39/ecmascript_sharedmem/issues/55).\n\nEven if ECMAScript were otherwise deterministically replayable, these\nunpredictable preemptive failures would prevent it. We examine instead\nthe weaker property of *fail-stop determinism*, where each replica\neither fails, or succeeds in a manner identical to every other\nnon-failing replica.\n\nAlthough few in number, there _are_ specification\nissues that are observably left to implementations, upon which\nimplementations may differ. Some of these may eventually be closed by\nfuture TC39 agreement, such as enumeration order if objects are\nmodified during enumeration (TODO link). Others, like the sort\nalgorithm used by `Array.prototype.sort` are less likely to be\nclosed. However, *implementation-defined* is not necessarily genuine\nnon-determinism. On a given implementation, operations which are only\nimplementation-defined can be deterministic within the scope of that\nimplementation. They should be fail-stop reproducible when run on the\nsame implementation. To make use of this for replay, however, we would\nneed to pin down what we mean by \"same implementation\", which seems\nslippery and difficult.\n\n### The punchlines\n\nEven without pinning down the precise meaning of\n\"implementation-defined\", a computation that is limited to fail-stop\nimplementation-defined determinism _**cannot read covert channels and\nside channels**_ that it was not explicitly enabled to read. Nothing\ncan practically prevent signalling on covert channels and side\nchannels, but approximations to determinism can practically prevent\nconfined computations from perceiving these signals.\n\n(TODO explain the anthropic side channel and how it differs from an\ninformation-flow termination channel.)\n\nFail-stop implementation-defined determinism is a **great boon to\ntesting and debugging**. All non-deterministic _dependencies_, like\nthe allegedly current time, can be mocked and _injected_ in a\nreproducible manner.\n\n\n## Annex B considerations\n\nAs of ES2016, the normative optionals of\n[Annex B](http://www.ecma-international.org/ecma-262/6.0/#sec-additional-ecmascript-features-for-web-browsers)\nare safe for inclusion as normative optionals of immutable root\nrealms. However, where Annex B states that these are normative\nmandatory in a web browser, there is no such requirement for immutable\nroot realms. Even when run in a web browser, an immutable root realm,\nhaving no host specific globals, must be considered a non-browser\nenvironment. Some post-ES2015 APIs proposed for Annex B, such as the\n[`RegExp` statics](https://github.com/claudepache/es-regexp-legacy-static-properties)\nand the\n[`Error.prototype.stack` accessor property](https://mail.mozilla.org/pipermail/es-discuss/2016-February/045579.html),\nare not safe for inclusion in immutable root realms and must be absent.\n\nAt this time, to maximize compatibility with normal ECMAScript, we do\nnot alter an immutable root realm's evaluators to evaluate code in\nstrict mode by default. However, we should consider doing so. Most of\nthe code, including legacy code, that one would wish to run under an\nimmutable root realm is probably already compatible with strict\nmode. Omitting sloppy mode from immutable root realms and their\nspawned descendants would also make sections\n[B.1.1](http://www.ecma-international.org/ecma-262/6.0/#sec-additional-syntax-numeric-literals),\n[B.1.2](http://www.ecma-international.org/ecma-262/6.0/#sec-additional-syntax-string-literals),\n[B.3.2](http://www.ecma-international.org/ecma-262/6.0/#sec-labelled-function-declarations),\n[B.3.3](http://www.ecma-international.org/ecma-262/6.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics),\nand\n[B.3.4](http://www.ecma-international.org/ecma-262/6.0/#sec-functiondeclarations-in-ifstatement-statement-clauses)\nnon issues. It is unclear what an immutable root realm's evaluators\nshould specify regarding the remaining normative optional syntax in\nsection B.1. But the syntax accepted by these evaluators, at least in\nstrict mode, should probably be pinned down precisely by the spec.\n\nSome of the elements of Annex B are safe and likely mandatory in\npractice, independent of host environment:\n\n  * `escape` and `unescape`\n  * `Object.prototype.__proto__`\n  * `String.prototype.substr`\n  * The `String.prototype` methods defined in terms of the internal\n    `CreateHTML`: `anchor`, `big`, ..., `sup`\n  * `Date.prototype.getYear` and `Date.prototype.setYear`\n  * `Date.prototype.toGMTString`\n  * [`__proto__` Property Names in Object\n     Initializers](http://www.ecma-international.org/ecma-262/6.0/#sec-__proto__-property-names-in-object-initializers)\n\nAll but the last of these have been\n[whitelisted in Caja's SES-shim](https://github.com/google/caja/blob/master/src/com/google/caja/ses/whitelist.js#L85)\nfor a long time without problem. (The last bullet above is syntax and\nso not subject to the SES-shim whitelisting mechanism.)\n\n\n## Discussion\n\nBecause an immutable root realm is transitively immutable, we can\nsafely share it between ECMAScript programs that are otherwise fully\nisolated. This sharing gives them access to shared objects and shared\nidentities, but no ability to communicate with each other or to affect\nany state outside themselves. We can even share immutable root realms\nbetween origins and between threads, since deep immutability at the\nspecification level should make thread safety at the implementation\nlevel straightforward.\n\nToday, to self-host builtins by writing them in ECMAScript, one must\npractice\n[safe meta programming](http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming)\ntechniques so that these builtins are properly defensive. This\ntechnique is difficult to get right, especially if such self hosting\nis\n[opened to ECMAScript embedders](https://docs.google.com/document/d/1AT5-T0aHGp7Lt29vPWFr2-qG8r3l9CByyvKwEuA8Ec0/edit#heading=h.ma18njbt74u3). Instead,\nthese builtins could be defined in a lightweight realm spawned from an\nimmutable root realm, making defensiveness easier to achieve with\nhigher confidence.\n\nBecause of the so-called \"[override mistake](\nhttp://wiki.ecmascript.org/doku.php?id=strawman:fixing_override_mistake)\",\nfor many or possibly all properties in this frozen state, primordial\nobjects need to be frozen in a pattern we call \"tamper proofing\",\nwhich makes them less compliant with the current language\nstandard. See the **Open Questions** below for other possibilities.\n\nBy the rules above, a spawned realm's `Function.prototype.constructor`\nwill be the parent realm's `Function` constructor, i.e., identical to\nthe spawned realm's `Function.__proto__`. In exchange for this odd\ntopology, we obtain the pleasant property that `instanceof` works\ntransparently between spawned realms by default -- unless overridden\nby a user's polyfill to the contrary.\n\nIn ES2016, the `GeneratorFunction` evaluator is not a named global,\nbut rather an unnamed intrinsic. Upcoming evaluators are likely to\ninclude `AsyncFunction` and `AsyncGeneratorFunction`. These are likely\nto be specified as unnamed instrinsics as well. For all of these, the\nabove name-based overriding of `spawn` is irrelevant and probably not\nneeded anyway.\n\nBecause code evaluated within an immutable root realm is unable to cause any\naffects outside itself it is not given explicit access to, the\nevaluators of an immutable root realm should continue to operate even in\nenvironments in which\n[CSP has forbidden normal evaluators](https://github.com/tc39/ecma262/issues/450). By\nanalogy, CSP evaluator suppression does not suppress\n`JSON.parse`. There are few ways in which evaluating code in\nan immutable root realm is more dangerous than JSON data.\n\nOther possible proposals, like\n[private state](https://zenparsing.github.io/es-private-fields/) and\n[defensible `const` classes](http://wiki.ecmascript.org/doku.php?id=harmony:classes#const),\nare likely to aid the defensive programming that is especially\npowerful in the context of this proposal. But because the utility of\nsuch defensive programming support is not limited to frozen realms,\nthey should remain independent proposals.\n\nFor each of the upcoming proposed standard APIs that are inherently\nnot immutable and powerless:\n\n  * [`defaultLoader`](https://github.com/whatwg/loader/issues/34)\n  * [`global`](https://github.com/tc39/proposal-global)\n  * [`makeWeakRef`](https://github.com/tc39/proposal-weakrefs/blob/master/specs/weakrefs.md)\n  * [`getStack`](https://mail.mozilla.org/pipermail/es-discuss/2016-February/045579.html)\n  * [`getStackString`](https://mail.mozilla.org/pipermail/es-discuss/2016-February/045579.html)\n\nthey must be absent from an immutable root realm, or have their\nbehavior grossly truncated into something safe. This spec will\nadditionally need to say how they initially appear, if at all, in each\nindividual spawned lightweight realm.  In particular, we expect a\npattern to emerge for creating a fresh loader instance to be the\ndefault loader of a fresh spawned realm. Once some proposed APIs are\nspecced as being provided by import from\n[builtin primordial modules](https://github.com/tc39/ecma262/issues/395),\nwe will need to explain how they appear in an immutable root realm\nand/or the realms it spawns.\n\n\n## Open Questions\n\n* Should `Realm.immutableRoot()` return a new fresh frozen realm each\n  time or should it always return the same one? Above we leave this\n  implementation-defined for now to encourage implementations to\n  experiment and see how efficient each can be made. If all can agree\n  on one of these options, we should codify that rather than continue\n  to leave this implementation-defined.\n\n* It remains unclear how we should cope with the override\n  mistake. Above, we propose the tamper proofing pattern, but this\n  requires novel effort to become efficient. Alternatively, we could\n  specify that the override mistake is fixed in an immutable root realm and\n  its descendants, making the problem go away. This diverges from the\n  current standard in a different way, but we have some evidence that\n  such divergence will break almost no existing code other than code\n  that specifically tests for standards compliance. We could also\n  leave it unfixed. This would break some good-practice legacy\n  patterns of overriding methods by assignment. But it is compatible\n  with overriding by classes and object literals, since they do\n  `[[DefineOwnProperty]]` rather than assignment.\n\n  Our sense is that not fixing the override mistake at all will\n  [break too much legacy code](https://esdiscuss.org/topic/object-freeze-object-prototype-vs-reality). But\n  if fully fixing the override mistake is too expensive, it might be\n  that fixing a handful of properties on primordial prototypes that\n  are overridden in practice (e.g., `constructor`, `toString`, ...)\n  will reduce the breakage to a tolerable level. We need measurements.\n\n* Although not officially a question within the jurisdiction of TC39,\n  we should discuss whether the existing CSP \"no script evaluation\"\n  settings should exempt an immutable root realm's evaluators, or whether CSP\n  should be extended in order to express this differential\n  prohibition.\n\n* Currently, if the value of `eval` is anything other than the\n  original value of `eval`, any use of it in the form of a direct-eval\n  expression will actually have the semantics of an indirect eval,\n  i.e., a simple function call to the current value of `eval`. If\n  an immutable root realm's builtin evaluators are not strict by default,\n  then any user customization that replaces a spawned realm's global\n  evaluators with strict-by-default wrappers will break their use for\n  direct-eval. Fortunately, this seems to be addressed by the rest of\n  the [old Realms API](https://gist.github.com/dherman/7568885).\n\n* The standard `Date` constructor reveals the current time either\n  * when called as a constructor with no arguments, or\n  * when called as a function (regardless of the arguments)\n\n  Above we propose to censor the current time by having the proto-Date\n  constructor throw a `TypeError` in those cases. Would another error type be\n  more appropriate? Instead of throwing an Error, should `new Date()` produce\n  an invalid date, equivalent to that produced by `new Date(NaN)`? If so,\n  calling the `Date` constructor as a function should produce the corresponding\n  string `\"Invalid Date\"`. If we go in this direction, conceivably we could\n  even have `Date.now()` return `NaN`. The advantage of removing `Date.now`\n  instead is to support the feature-testing style practiced by ECMAScript\n  programmers.\n\n* Of course, there is the perpetual bikeshedding of names. We are not\n  attached to the names we present here.\n\n## Spec Text\n\n### Updating the spec text for this proposal\n\nThe source for the spec text is located in [spec/index.emu](spec/index.emu) and it is written in\n[ecmarkup](https://github.com/bterlson/ecmarkup) language.\n\nWhen modifying the spec text, you should be able to build the HTML version in\n`index.html` by using the following command:\n\n```bash\nnpm install\nnpm run build\nopen index.html\n```\n\nAlternative, you can use `npm run watch`.\n\n## Acknowledgements\n\nMany thanks to E. Dean Tribble, Kevin Reid, Dave Herman, Michael\nFicarra, Tom Van Cutsem, Kris Kowal, Kevin Smith, Terry Hayes, Daniel\nEhrenberg, Ojan Vafai, Elliott Sprehn, and Alex Russell. Thanks to the\nentire Caja team (Jasvir Nagra, Ihab Awad, Mike Stay, Mike Samuel,\nFelix Lee, Kevin Reid, and Ben Laurie) for building a system in which all the\nhardest issues have already been worked out.\n"
            }
          },
          {
            "name": "process-document",
            "description": "Document describing the process for making changes to ES262",
            "githubUrl": "https://github.com/tc39/process-document",
            "specUrl": "https://tc39.github.io/process-document/",
            "readme": null
          }
        ]
      }
    }
  }
}
